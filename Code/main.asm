;
; tris
;	1=Input  0=Output
;
;
; OPTION
; bit 7 GPWU: Enable Wake-up on Pin Change bit (GP0, GP1, GP3) 1 = Disabled 0 = Enabled
; bit 6 GPPU: Enable Weak Pull-ups bit (GP0, GP1, GP3) 1 = Disabled 0 = Enabled
; bit 5 T0CS: Timer0 Clock Source Select bit 1 = Transition on T0CKI pin (overrides tris on the T0CKI pin) 0 = Transition on internal instruction cycle clock, FOSC/4
; bit 4 T0SE: Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on the T0CKI pin 0 = Increment on low-to-high transition on the T0CKI pin
; bit 3 PSA: Prescaler Assignment bit 1 = Prescaler assigned to the WDT 0 = Prescaler assigned to Timer0
; bit 2-0 PS<2:0>: Prescaler Rate Select bits
;	000 1 : 2	1 : 1
;	001 1 : 4	1 : 2
;	010 1 : 8	1 : 4
;	011 1 : 16	1 : 8
;	100 1 : 32	1 : 16
;	101 1 : 64	1 : 32
;	110 1 : 128	1 : 64
;	111 1 : 256	1 : 128
;
	

	list      p=10F202            ; list directive to define processor
	#include <p10F202.inc>        ; processor specific variable definitions
	errorlevel -227

;	__CONFIG   _MCLRE_ON & _CP_OFF & _WDT_OFF
	__CONFIG   _MCLRE_OFF & _CP_OFF & _WDT_OFF


	cblock 0x08
		count1
		count2
		randHi
		randLo
		statustemp
		temp
	endc


	ORG     0x1FF             ; processor reset vector

; Internal RC calibration value is placed at location 0x1FF by Microchip
; as a movlw k, where the k is a literal value.

	ORG     0x000             ; Start of code
	movwf   OSCCAL            ; update register with factory cal value

	movlw B'11000111'		; NoWake, NoPullup, F/4, LoHi, PreT0, 1:256
	OPTION

	movlw 	0x30
	movwf 	randHi
	movlw 	0x45
	movwf 	randLo

;
;
;
;
	call 	Led1
	movlw	0xFF
	call	DelayWms

	call 	Led2
	movlw	0xFF
	call	DelayWms

	call 	Led3
	movlw	0xFF
	call	DelayWms

	call 	Led4
	movlw	0xFF
	call	DelayWms

	call 	Led5
	movlw	0xFF
	call	DelayWms

	call 	Led6
	movlw	0xFF
	call	DelayWms


touch
	movlw	0x10
	call	DelayWms
	call 	LedOff
	movlw	0x80
	call	DelayWms
	movf	GPIO, W	
	andlw	0x08
	btfsc	STATUS,Z
	goto 	touch2
	call 	Led3
	goto 	touch
touch2
	call	Led4
	goto 	touch


RandomFlashLoop
	movlw	0x05
	call	DelayWms
	call 	LedOff
	movlw	0x80
	call	DelayWms

RedoRandom
	call	Random16
	movf	randLo, W
	andlw	0x07
	movwf	temp
	btfsc	STATUS,Z
	goto	R1

	decf	temp, F
	btfsc	STATUS,Z
	goto	R2

	decf	temp, F
	btfsc	STATUS,Z
	goto	R3

	decf	temp, F
	btfsc	STATUS,Z
	goto	R4

	decf	temp, F
	btfsc	STATUS,Z
	goto	R5

	decf	temp, F
	btfsc	STATUS,Z
	goto	R6

	goto	RedoRandom

R1
	call	Led1
	goto 	RandomFlashLoop
R2
	call	Led2
	goto 	RandomFlashLoop
R3
	call	Led3
	goto 	RandomFlashLoop
R4
	call	Led4
	goto 	RandomFlashLoop
R5
	call	Led5
	goto 	RandomFlashLoop
R6
	call	Led6
	goto 	RandomFlashLoop


Loop1
	call 	Led1
	movlw	0xFF
	call	DelayWms

	call 	Led2
	movlw	0xFF
	call	DelayWms

	call 	Led3
	movlw	0xFF
	call	DelayWms

	call 	Led4
	movlw	0xFF
	call	DelayWms

	call 	Led5
	movlw	0xFF
	call	DelayWms

	call 	Led6
	movlw	0xFF
	call	DelayWms

	goto	Loop1


LedOff
	clrf	GPIO			; GP0=Low GP1=Low GP2=Low
	movlw	B'11111111'		; All GP Input
	tris	GPIO
	return

Led1
	movlw	B'00000001'		; GP0=Hi GP1=Low
	movwf	GPIO
	movlw	B'11111100'		; GP0 & GP1 Output
	tris	GPIO
	return

Led2
	movlw	B'00000010'		; GP0=Low GP1=Hi
	movwf	GPIO
	movlw	B'11111100'		; GP0 & GP1 Output
	tris	GPIO
	return

Led3
	movlw	B'00000001'		; GP0=Hi GP2=Low
	movwf	GPIO
	movlw	B'11111010'		; GP0 & GP2 Output
	tris	GPIO
	return

Led4
	movlw	B'00000100'		; GP0=Low GP2=Hi 
	movwf	GPIO
	movlw	B'11111010'		; GP0 & GP2 Output
	tris	GPIO
	return

Led5
	movlw	B'00000010'		; GP1=Hi GP2=Low
	movwf	GPIO
	movlw	B'11111001'		; GP1 & GP2 Output
	tris	GPIO
	return

Led6
	movlw	B'00000100'		; GP1=Low GP2=Hi
	movwf	GPIO
	movlw	B'11111001'		; GP1 & GP2 Output
	tris	GPIO
	return



;*******************************************************************
;
; Delay for "w" ms
;
; This should be really be implemented as a TMR0 based delay with 
; cpu sleep mode.
;
;*******************************************************************
DelayWms							;variable delay
	movwf 	count1
	incf 	count1, F				;because 0 would give long delay
loopw1

	movlw	0xFF
	movwf	count2
loopw2
	decfsz 	count2,F
	goto	loopw2

	decfsz 	count1,F
	goto 	loopw1
	return				




;*******************************************************************
;
; Random Number Generator
;
; This routine generates a 16 Bit Pseudo Sequence Random Generator
; It is based on Linear shift register feedback. The sequence
; is generated by (Q15 xorwf Q14 xorwf Q12 xorwf Q3 )
;
; The 16 bit random number is in location RandHi(high byte)
; & RandLo (low byte)
;
; Before calling this routine, make sure the initial values
; of RandHi & RandLo are NOT ZERO
; A good choise of initial random number is 0x3045
;*******************************************************************
;
Random16
	rlf 	randHi,W
	xorwf 	randHi,W
	movwf 	temp
	rlf 	temp, W 		; carry bit = xorwf(Q15,14)
	swapf 	randHi, F
	swapf	randLo, W
	movf 	STATUS, W
	movwf 	statustemp

	bcf 	STATUS, C
	movwf 	temp
	rlf 	temp, F
	btfsc 	STATUS, C
	bsf 	temp, 0

	movf 	statustemp, W
	movwf 	STATUS


	movf 	temp, W


	xorwf 	randHi,W 		; LSB = xorwf(Q12,Q3)
	swapf 	randHi, F
	andlw 	0x01

	rlf 	randLo, F
	xorwf 	randLo, F
	rlf 	randHi, F
	return




	END
